final class Line: Equatable, Coding, Interpolatable {
    let points: [CGPoint], pressures: [Float], imageBounds: CGRect
    init(points: [CGPoint] = [CGPoint](), pressures: [Float]) {
        self.points = points
        self.pressures = pressures
        self.imageBounds = Line.imageBounds(with: points)
    }
    private init(points: [CGPoint], pressures: [Float], imageBounds: CGRect) {
        self.points = points
        self.pressures = pressures
        self.imageBounds = imageBounds
    }
    init(coder: Coder) {
        points = coder.decode()
        pressures = coder.decode()
        imageBounds = coder.decode()
    }
    func encode(with coder: Coder) {
        coder.encode(points)
        coder.encode(pressures)
        coder.encode(imageBounds)
    }
    func withPoints(_ points: [CGPoint]) -> Line {
        return Line(points: points, pressures: pressures)
    }
    func withPressures(_ pressures: [Float]) -> Line {
        return Line(points: points, pressures: pressures, imageBounds: imageBounds)
    }
    func withAppendPoint(_ point: CGPoint, pressure: Float?) -> Line {
        var _points = points, _pressures = pressures
        _points.append(point)
        if let pre = pressure {
            _pressures.append(pre)
        }
        return Line(points: _points, pressures: _pressures)
    }
    func withInsertPoint(_ point: CGPoint, pressure: Float?, atIndex i: Int) -> Line {
        var _points = points, _pressures = pressures
        _points.insert(point, at: i)
        if let pre = pressure {
            _pressures.insert(pre, at: i)
        }
        return Line(points: _points, pressures: _pressures)
    }
    func withRemovePoint(atIndex i: Int) -> Line {
        var _points = points, _pressures = pressures
        _points.remove(at: i)
        if !_pressures.isEmpty {
            _pressures.remove(at: i)
        }
        return Line(points: _points, pressures: _pressures)
    }
    func withReplacedPoint(_ point : CGPoint, atIndex i: Int) -> Line {
        var _points = points
        _points[i] = point
        return withPoints(_points)
    }
    func withReplacedPoint(_ point : CGPoint, pressure: Float, atIndex i: Int) -> Line {
        var _points = points
        _points[i] = point
        var _pressures = pressures
        if !_pressures.isEmpty {
            _pressures[i] = pressure
        }
        return Line(points: _points, pressures: _pressures)
    }
    func transformed(with affine: CGAffineTransform) -> Line {
        let newPoints = points.map { $0.applying(affine) }
        return Line(points: newPoints, pressures: pressures)
    }
    func warpedWith(deltaPoint dp: CGPoint, isFirst: Bool) -> Line {
        var allD = 0.0.cf, oldP = firstPoint
        for i in 1 ..< count {
            let p = points[i]
            allD += sqrt(p.squaredDistance(other: oldP))
            oldP = p
        }
        oldP = firstPoint
        let invertAllD = allD > 0 ? 1/allD : 0
        var ps = [CGPoint]()
        var allAD = 0.0.cf
        for i in 0 ..< count {
            let p = points[i]
            allAD += sqrt(p.squaredDistance(other: oldP))
            oldP = p
            let t = isFirst ? 1 - allAD*invertAllD : allAD*invertAllD
            var np = points[i]
            np.x += dp.x*t
            np.y += dp.y*t
            ps.append(np)
        }
        return Line(points: ps, pressures: pressures)
    }
    func warpedWith(deltaPoint dp: CGPoint, editPoint: CGPoint, minDistance: CGFloat, maxDistance: CGFloat) -> Line {
        let nfps: [CGPoint] = points.map { lp in
            let d =  hypot2(lp.x - editPoint.x, lp.y - editPoint.y)
            let ds = (1 - (d - minDistance)/(maxDistance - minDistance))
            return CGPoint(x: lp.x + dp.x*ds, y: lp.y + dp.y*ds)
        }
        return Line(points: nfps, pressures: pressures)
    }
    static func linear(_ f0: Line, _ f1: Line, t: CGFloat) -> Line {
        let count = max(f0.points.count, f1.points.count)
        var points = [CGPoint]()
        points.reserveCapacity(count)
        for i in 0 ..< count {
            points.append(CGPoint.linear(f0.point(at: i, maxCount: count), f1.point(at: i, maxCount: count), t: t))
        }
        return Line(points: points, pressures: f1.pressures)
    }
    static func spline(_ f0: Line, _ f1: Line, _ f2: Line, _ f3: Line, t: CGFloat) -> Line {
        let count = max(f0.points.count, f1.points.count, f2.points.count, f3.points.count)
        let points: [CGPoint] = (0 ..< count).map { i in
            let f0i = f0.point(at: i, maxCount: count), f1i = f1.point(at: i, maxCount: count), f2i = f2.point(at: i, maxCount: count), f3i = f3.point(at: i, maxCount: count)
            return f1i == f2i ? f1i : CGPoint.spline(f0i, f1i, f2i, f3i, t: t)
        }
        return Line(points: points, pressures: f1.pressures)
    }
    static func firstSpline(_ f1: Line, _ f2: Line, _ f3: Line, t: CGFloat) -> Line {
        let count = max(f1.points.count, f2.points.count, f3.points.count)
        let points: [CGPoint] = (0 ..< count).map { i in
            let f1i = f1.point(at: i, maxCount: count), f2i = f2.point(at: i, maxCount: count), f3i = f3.point(at: i, maxCount: count)
            return f1i == f2i ? f1i : CGPoint.firstSpline(f1i, f2i, f3i, t: t)
        }
        return Line(points: points, pressures: f1.pressures)
    }
    static func endSpline(_ f0: Line, _ f1: Line, _ f2: Line, t: CGFloat) -> Line {
        let count = max(f0.points.count, f1.points.count, f2.points.count)
        let points: [CGPoint] = (0 ..< count).map { i in
            let f0i = f0.point(at: i, maxCount: count), f1i = f1.point(at: i, maxCount: count), f2i = f2.point(at: i, maxCount: count)
            return f1i == f2i ? f1i : CGPoint.endSpline(f0i, f1i, f2i, t: t)
            }
        return Line(points: points, pressures: f1.pressures)
    }
    private func point(at i: Int, maxCount: Int) -> CGPoint {
        if points.count == maxCount {
            return points[i]
        } else if points.count < 1 {
            return CGPoint()
        } else {
            let d = maxCount - points.count
            let minD = d/2
            if i < minD {
                return points[0]
            } else if i > maxCount - (d - minD) - 1 {
                return points[points.count - 1]
            } else {
                return points[i - minD]
            }
        }
    }
    func reversed() -> Line {
        return Line(points: points.reversed(), pressures: pressures)
    }
    func splited(startIndex: Int, endIndex: Int) -> Line {
        return Line(points: Array(points[startIndex...endIndex]), pressures: pressures.isEmpty ? [] : Array(pressures[startIndex...endIndex]))
    }
    
    //Bezier3
    func splited(startIndex: Int, startT: CGFloat, endIndex: Int, endT: CGFloat) -> Line {
        if startIndex == endIndex {
            let b = bezier(at: startIndex), t0 = CGFloat.linear(startT, endT, t: 0.3), t1 = CGFloat.linear(startT, endT, t: 0.7)
            let ps = [b.position(with: startT), b.position(with: t0), b.position(with: t1), b.position(with: endT)]
            let prs = [pressure(at: startIndex, t: startT), pressure(at: startIndex, t: t0), pressure(at: startIndex, t: t1), pressure(at: endIndex, t: endT)]
            return Line(points: ps, pressures: prs)
        } else {
            var ps = Array(points[startIndex + 1 ..< endIndex + 1])
            if startIndex == 0 && startT == 0 {
                ps.insert(points[0], at: 0)
            } else {
                ps.insert(bezier(at: startIndex).position(with: startT), at: 0)
            }
            if endIndex == count - 2 && endT == 1 {
                ps.append(points[count - 1])
            } else {
                ps.append(bezier(at: endIndex).position(with: endT))
            }
            if !pressures.isEmpty {
                var prs = Array(pressures[startIndex + 1 ..< endIndex + 1])
                if startIndex == 0 && startT == 0 {
                    prs.insert(pressures[0], at: 0)
                } else {
                    prs.insert(pressure(at: startIndex, t: startT), at: 0)
                }
                if endIndex == count - 2 && endT == 1 {
                    prs.append(pressures[count - 1])
                } else {
                    prs.append(pressure(at: endIndex, t: endT))
                }
                return Line(points: ps, pressures: prs)
            } else {
                return Line(points: ps, pressures: [])
            }
        }
    }
    var count: Int {
        return points.count
    }
    var firstPoint: CGPoint {
        return points[0]
    }
    var lastPoint: CGPoint {
        return points[points.count - 1]
    }
    func pressure(at index: Int) -> Float {
        return pressures.isEmpty ? 1 : pressures[index]
    }
    func pressure(at i: Int, t: CGFloat) -> Float {
        return pressures.isEmpty ? 1 : (i  > 0 ? Float.linear(pressures[i], pressures[i - 1], t: t) : pressures[i])
    }
    private static func imageBounds(with points: [CGPoint]) -> CGRect {
        if let fp = points.first, let lp = points.last {
            if points.count == 2 {
                return Bezier3.linear(fp, lp).bounds
            } else if points.count >= 3 {
                var b = Bezier3.firstSpline(fp, points[1], points[2]).bounds
                for i in 1 ..< points.count - 2 {
                    b = b.union(Bezier3.spline(points[i - 1], points[i], points[i + 1], points[i + 2]).bounds)
                }
                b = b.union(Bezier3.endSpline(points[points.count - 3], points[points.count - 2], lp).bounds)
                return b
            }
        }
        return CGRect()
    }
    static func imageBounds(with lines: [Line], lineWidth: CGFloat) -> CGRect {
        if var firstBounds = lines.first?.imageBounds {
            for line in lines {
                firstBounds = firstBounds.union(line.imageBounds)
            }
            return firstBounds.insetBy(dx: -lineWidth/2, dy: -lineWidth/2)
        } else {
            return CGRect()
        }
    }
    func bezier(at i: Int) -> Bezier3 {
        if count < 3 {
            return Bezier3.linear(firstPoint, lastPoint)
        } else if i == 0 {
            return Bezier3.firstSpline(points[0], points[1], points[2])
        } else if i == count - 2 {
            return Bezier3.endSpline(points[points.count - 3], points[points.count - 2], points[points.count - 1])
        } else {
            return Bezier3.spline(points[i - 1], points[i], points[i + 1], points[i + 2])
        }
    }
    func angle(withPreviousLine preLine: Line) -> CGFloat {
        let t1 = preLine.count >= 2 ? preLine.points[preLine.count - 2].tangential(preLine.points[preLine.count - 1])  : 0
        let t2 = count >= 2 ? points[0].tangential(points[1])  : 0
        return fabs(t1.differenceRotation(t2))
    }
    var lastBoundingBox: CGRect {
        if count < 3 {
            return Bezier3.linear(firstPoint, lastPoint).boundingBox
        } else if count == 3 {
            return imageBounds
        } else {
            return Bezier3.spline(points[points.count - 4], points[points.count - 3], points[points.count - 2], points[points.count - 1]).boundingBox.union(Bezier3.endSpline(points[points.count - 3], points[points.count - 2], points[points.count - 1]).boundingBox)
        }
    }
    func intersects(_ bezier: Bezier3) -> Bool {
        if imageBounds.intersects(bezier.boundingBox) {
            var intersects = false
            allBeziers { ob, index, stop in
                if bezier.intersects(ob) {
                    intersects = true
                    stop = true
                }
            }
            return intersects
        } else {
            return false
        }
    }
    func intersects(_ other: Line) -> Bool {
        if imageBounds.intersects(other.imageBounds) {
            var intersects = false
            allBeziers { bezier, index, stop in
                if other.intersects(bezier) {
                    intersects = true
                    stop = true
                }
            }
            return intersects
        } else {
            return false
        }
    }
    func intersects(_ bounds: CGRect) -> Bool {
        if imageBounds.intersects(bounds) {
            if bounds.contains(firstPoint) {
                return true
            }
            let x0y0 = bounds.origin, x1y0 = CGPoint(x: bounds.maxX, y: bounds.minY)
            let x0y1 = CGPoint(x: bounds.minX, y: bounds.maxY), x1y1 = CGPoint(x: bounds.maxX, y: bounds.maxY)
            if intersects(Bezier3.linear(x0y0, x1y0)) || intersects(Bezier3.linear(x1y0, x1y1)) || intersects(Bezier3.linear(x1y1, x0y1)) || intersects(Bezier3.linear(x0y1, x0y0)) {
                return true
            }
        }
        return false
    }
    func isReverse(from other: Line) -> Bool {
        let l0 = other.points[other.points.count - 1], f1 = points[0], l1 = points[points.count - 1]
        return hypot2(l1.x - l0.x, l1.y - l0.y) < hypot2(f1.x - l0.x, f1.y - l0.y)
    }
    func pointWith(deltaPoint: CGPoint, index: Int, oldPoint: CGPoint) -> CGPoint {
        return CGPoint(x: oldPoint.x + deltaPoint.x, y: oldPoint.y + deltaPoint.y)
    }
    func bezierTWith(length: CGFloat) -> (b: Bezier3, t: CGFloat)? {
        var bs: (b: Bezier3, t: CGFloat)?, allD = 0.0.cf
        allBeziers { b, index, stop in
            let d = b.length()
            let newAllD = allD + d
            if length < newAllD && d > 0 {
                bs = (b, b.tWith(length: length - allD))
                stop = true
            }
            allD = newAllD
        }
        return bs
    }
    var pointsLength: CGFloat {
        var length = 0.0.cf
        if var oldPoint = points.first {
            for point in points {
                length += hypot(point.x - oldPoint.x, point.y - oldPoint.y)
                oldPoint = point
            }
        }
        return length
    }
    func allEditPoints(_ handler: (_ point: CGPoint, _ index: Int, _ stop: inout Bool) -> Void) {
        var stop = false
        for (i, p) in points.enumerated() {
            handler(p, i, &stop)
            if stop {
                return
            }
        }
    }
    func allBeziers(_ handler: (_ bezier: Bezier3) -> Void) {
        if let fp = points.first, let lp = points.last {
            if points.count == 2 {
                handler(Bezier3.linear(fp, lp))
            } else if points.count >= 3 {
                handler(Bezier3.firstSpline(fp, points[1], points[2]))
                for i in 1 ..< points.count - 2 {
                    handler(Bezier3.spline(points[i - 1], points[i], points[i + 1], points[i + 2]))
                }
                handler(Bezier3.endSpline(points[points.count - 3], points[points.count - 2], lp))
            }
        }
    }
    func allBeziers(_ handler: (_ bezier: Bezier3, _ index: Int, _ stop: inout Bool) -> Void) {
        var stop = false
        if let fp = points.first, let lp = points.last {
            if points.count == 2 {
                handler(Bezier3.linear(fp, lp), 0, &stop)
            } else if points.count >= 3 {
                handler(Bezier3.firstSpline(fp, points[1], points[2]), 0, &stop)
                for i in 1 ..< points.count - 2 {
                    handler(Bezier3.spline(points[i - 1], points[i], points[i + 1], points[i + 2]), i, &stop)
                    if stop {
                        return
                    }
                }
                handler(Bezier3.endSpline(points[points.count - 3], points[points.count - 2], lp), points.count - 2, &stop)
            }
        }
    }
    func addPoints(isMove: Bool, inPath: CGMutablePath) {
        if isMove {
            inPath.move(to: firstPoint)
        }
        allBeziers {
            inPath.addCurve(to: $0.p1, control1: $0.cp0, control2: $0.cp1)
        }
    }
    private struct PressurePoint {
        let point: CGPoint, deltaPoint: CGPoint
        var leftPoint: CGPoint {
            return point + deltaPoint
        }
        var rightPoint: CGPoint {
            return point - deltaPoint
        }
    }
    func draw(size: CGFloat, in ctx: CGContext) {
        ctx.move(to: points.first!)
        allBeziers {
            ctx.addCurve(to: $0.p1, control1: $0.cp0, control2: $0.cp1)
        }
        ctx.setLineWidth(size/2)
        ctx.setStrokeColor(NSColor.black.cgColor)
        ctx.strokePath()
    }
    func drawAutoPressure(size: CGFloat, firstPressure fpr: Float, lastPressure lpr: Float, in ctx: CGContext) {
        let s = size/2
        if points.count >= 2, ctx.boundingBoxOfClipPath.intersects(imageBounds.inset(by: -s)), let fp = points.first, let lp = points.last {
            let fprs = fpr.cf*s, lprs = lpr.cf*s
            let _points = points.count == 2 ? [fp, (fp).mid(lp), lp] : points
            var ps = [PressurePoint]()
            ps.reserveCapacity(points.count)
            var p1 = _points[1], midP0P1 = fp, p0p1 = atan2(p1.y - fp.y, p1.x - fp.x)
            let fTheta = .pi/2 + p0p1, dt = 1/Float(_points.count - 1)
            ps.append(PressurePoint(point: fp, deltaPoint: CGPoint(x: fprs*cos(fTheta), y: fprs*sin(fTheta))))
            for i in 2 ..< _points.count - 1 {
                let p2 = _points[i], hs = autoPressure(dt*Float(i - 1), fp: fpr, lp: lpr).cf*s
                let p1p2 = atan2(p2.y - p1.y, p2.x - p1.x), midP1P2 = p1.mid(p2)
                addPressurePointWith(p0: midP0P1, p1: p1, p2: midP1P2, p0p1: p0p1, p1p2: p1p2, halfSize: hs, inPressurePoints: &ps)
                p1 = p2
                midP0P1 = midP1P2
                p0p1 = p1p2
            }
            let p1p2 = atan2(lp.y - p1.y, lp.x - p1.x), lhs = autoPressure(dt*Float(_points.count - 2), fp: fpr, lp: lpr).cf*s
            addPressurePointWith(p0: midP0P1, p1: p1, p2: lp, p0p1: p0p1, p1p2: p1p2, halfSize: lhs, inPressurePoints: &ps)
            let ltheta = .pi/2 + p1p2
            ps.append(PressurePoint(point: lp, deltaPoint: CGPoint(x: lprs*cos(ltheta), y: lprs*sin(ltheta))))
            addSplinePoints(ps, in: ctx)
            ctx.fillPath()
        }
    }
    private func autoPressure(_ t: Float, fp: Float, lp: Float) -> Float {
        return 4*((t < 0.5 ? fp : lp) - 1)*(t  - 0.5)*(t - 0.5) + 1
    }
    private func addPressurePointWith(p0: CGPoint, p1: CGPoint, p2: CGPoint, p0p1: CGFloat, p1p2: CGFloat, halfSize prs: CGFloat, inPressurePoints ps: inout [PressurePoint]) {
        let p0p2 = atan2(p2.y - p0.y, p2.x - p0.x)
        let theta0 = .pi/2 + (p0p1 + p0p2.loopValue(other: p0p1, begin: -.pi, end: .pi))/2
        ps.append(PressurePoint(point: p0.mid(p1), deltaPoint: CGPoint(x: prs*cos(theta0), y: prs*sin(theta0))))
        let theta1 = .pi/2 + (p0p2 + p1p2.loopValue(other: p0p2, begin: -.pi, end: .pi))/2
        ps.append(PressurePoint(point: p1.mid(p2), deltaPoint: CGPoint(x: prs*cos(theta1), y: prs*sin(theta1))))
    }
    private func addSplinePoints(_ ps: [PressurePoint], in ctx: CGContext) {
        var op = ps[0].leftPoint
        ctx.move(to: op)
        op = ps[1].leftPoint
        if ps.count > 3 {
            for i in 2 ..< ps.count - 1 {
                let p = ps[i].leftPoint
                ctx.addQuadCurve(to: op.mid(p), control: op)
                op = p
            }
            let lp = ps[ps.count - 1]
            ctx.addQuadCurve(to: lp.leftPoint, control: op)
            ctx.addLine(to: lp.rightPoint)
            op = ps[ps.count - 2].rightPoint
            for i in (1...ps.count - 3).reversed() {
                let p = ps[i].rightPoint
                ctx.addQuadCurve(to: op.mid(p), control: op)
                op = p
            }
        } else {
            let lp = ps[ps.count - 1]
            ctx.addQuadCurve(to: lp.leftPoint, control: op)
            ctx.addLine(to: lp.rightPoint)
            op = ps[1].rightPoint
        }
        ctx.addQuadCurve(to: ps[0].rightPoint, control: op)
    }
    private func addLinearLinePoints(fp: CGPoint, lp: CGPoint, fprs: CGFloat, lprs: CGFloat, in ctx: CGContext) {
        let theta = .pi/2 + atan2(lp.y - fp.y, lp.x - fp.x)
        let cf = fprs*cos(theta), sf = fprs*sin(theta), cf2 = lprs*cos(theta), sf2 = lprs*sin(theta)
        ctx.move(to: CGPoint(x: fp.x + cf, y: fp.y + sf))
        ctx.addLine(to: CGPoint(x: lp.x + cf2, y: lp.y + sf2))
        ctx.addLine(to: CGPoint(x: lp.x - cf2, y: lp.y - sf2))
        ctx.addLine(to: CGPoint(x: fp.x - cf, y: fp.y - sf))
    }
}
func ==(lhs: Line, rhs: Line) -> Bool {
    return lhs === rhs
}



    func splited(startIndex: Int, startT: CGFloat, endIndex: Int, endT: CGFloat) -> Line {
        if startIndex == endIndex {
            let b = bezier(at: startIndex), t0 = CGFloat.linear(startT, endT, t: 0.3), t1 = CGFloat.linear(startT, endT, t: 0.7)
            let ps = [b.position(with: startT), b.position(with: t0), b.position(with: t1), b.position(with: endT)]
            let prs = [pressure(at: startIndex, t: startT), pressure(at: startIndex, t: t0), pressure(at: startIndex, t: t1), pressure(at: endIndex, t: endT)]
            return Line(points: ps, pressures: prs)
        } else {
            var ps = Array(points[startIndex + 1 ..< endIndex + 1])
            if startIndex == 0 && startT == 0 {
                ps.insert(points[0], at: 0)
            } else {
                ps.insert(bezier(at: startIndex).position(with: startT), at: 0)
            }
            if endIndex == count - 2 && endT == 1 {
                ps.append(points[count - 1])
            } else {
                ps.append(bezier(at: endIndex).position(with: endT))
            }
            if !pressures.isEmpty {
                var prs = Array(pressures[startIndex + 1 ..< endIndex + 1])
                if startIndex == 0 && startT == 0 {
                    prs.insert(pressures[0], at: 0)
                } else {
                    prs.insert(pressure(at: startIndex, t: startT), at: 0)
                }
                if endIndex == count - 2 && endT == 1 {
                    prs.append(pressures[count - 1])
                } else {
                    prs.append(pressure(at: endIndex, t: endT))
                }
                return Line(points: ps, pressures: prs)
            } else {
                return Line(points: ps, pressures: [])
            }
        }
    }
    var count: Int {
        return points.count
    }
    var firstPoint: CGPoint {
        return points[0]
    }
    var lastPoint: CGPoint {
        return points[points.count - 1]
    }
    func pressure(at index: Int) -> Float {
        return pressures.isEmpty ? 1 : pressures[index]
    }
    func pressure(at i: Int, t: CGFloat) -> Float {
        return pressures.isEmpty ? 1 : (i  > 0 ? Float.linear(pressures[i], pressures[i - 1], t: t) : pressures[i])
    }
    private static func imageBounds(with points: [CGPoint]) -> CGRect {
        if let fp = points.first, let lp = points.last {
            if points.count == 2 {
                return Bezier3.linear(fp, lp).bounds
            } else if points.count >= 3 {
                var b = Bezier3.firstSpline(fp, points[1], points[2]).bounds
                for i in 1 ..< points.count - 2 {
                    b = b.union(Bezier3.spline(points[i - 1], points[i], points[i + 1], points[i + 2]).bounds)
                }
                b = b.union(Bezier3.endSpline(points[points.count - 3], points[points.count - 2], lp).bounds)
                return b
            }
        }
        return CGRect()
    }
    static func imageBounds(with lines: [Line], lineWidth: CGFloat) -> CGRect {
        if var firstBounds = lines.first?.imageBounds {
            for line in lines {
                firstBounds = firstBounds.union(line.imageBounds)
            }
            return firstBounds.insetBy(dx: -lineWidth/2, dy: -lineWidth/2)
        } else {
            return CGRect()
        }
    }
    func bezier(at i: Int) -> Bezier3 {
        if count < 3 {
            return Bezier3.linear(firstPoint, lastPoint)
        } else if i == 0 {
            return Bezier3.firstSpline(points[0], points[1], points[2])
        } else if i == count - 2 {
            return Bezier3.endSpline(points[points.count - 3], points[points.count - 2], points[points.count - 1])
        } else {
            return Bezier3.spline(points[i - 1], points[i], points[i + 1], points[i + 2])
        }
    }
    func angle(withPreviousLine preLine: Line) -> CGFloat {
        let t1 = preLine.count >= 2 ? preLine.points[preLine.count - 2].tangential(preLine.points[preLine.count - 1])  : 0
        let t2 = count >= 2 ? points[0].tangential(points[1])  : 0
        return fabs(t1.differenceRotation(t2))
    }
    var lastBoundingBox: CGRect {
        if count < 3 {
            return Bezier3.linear(firstPoint, lastPoint).boundingBox
        } else if count == 3 {
            return imageBounds
        } else {
            return Bezier3.spline(points[points.count - 4], points[points.count - 3], points[points.count - 2], points[points.count - 1]).boundingBox.union(Bezier3.endSpline(points[points.count - 3], points[points.count - 2], points[points.count - 1]).boundingBox)
        }
    }
    func intersects(_ bezier: Bezier3) -> Bool {
        if imageBounds.intersects(bezier.boundingBox) {
            var intersects = false
            allBeziers { ob, index, stop in
                if bezier.intersects(ob) {
                    intersects = true
                    stop = true
                }
            }
            return intersects
        } else {
            return false
        }
    }
    func intersects(_ other: Line) -> Bool {
        if imageBounds.intersects(other.imageBounds) {
            var intersects = false
            allBeziers { bezier, index, stop in
                if other.intersects(bezier) {
                    intersects = true
                    stop = true
                }
            }
            return intersects
        } else {
            return false
        }
    }
    func intersects(_ bounds: CGRect) -> Bool {
        if imageBounds.intersects(bounds) {
            if bounds.contains(firstPoint) {
                return true
            }
            let x0y0 = bounds.origin, x1y0 = CGPoint(x: bounds.maxX, y: bounds.minY)
            let x0y1 = CGPoint(x: bounds.minX, y: bounds.maxY), x1y1 = CGPoint(x: bounds.maxX, y: bounds.maxY)
            if intersects(Bezier3.linear(x0y0, x1y0)) ||
                intersects(Bezier3.linear(x1y0, x1y1)) ||
                intersects(Bezier3.linear(x1y1, x0y1)) ||
                intersects(Bezier3.linear(x0y1, x0y0)) {
                return true
            }
        }
        return false
    }
    func isReverse(from other: Line) -> Bool {
        let l0 = other.points[other.points.count - 1], f1 = points[0], l1 = points[points.count - 1]
        return hypot2(l1.x - l0.x, l1.y - l0.y) < hypot2(f1.x - l0.x, f1.y - l0.y)
    }
    func pointWith(deltaPoint: CGPoint, index: Int, oldPoint: CGPoint) -> CGPoint {
        return CGPoint(x: oldPoint.x + deltaPoint.x, y: oldPoint.y + deltaPoint.y)
    }
    func bezierTWith(length: CGFloat) -> (b: Bezier3, t: CGFloat)? {
        var bs: (b: Bezier3, t: CGFloat)?, allD = 0.0.cf
        allBeziers { b, index, stop in
            let d = b.length()
            let newAllD = allD + d
            if length < newAllD && d > 0 {
                bs = (b, b.tWith(length: length - allD))
                stop = true
            }
            allD = newAllD
        }
        return bs
    }
    var pointsLength: CGFloat {
        var length = 0.0.cf
        if var oldPoint = points.first {
            for point in points {
                length += hypot(point.x - oldPoint.x, point.y - oldPoint.y)
                oldPoint = point }
        }
        return length
    }
    func allEditPoints(_ handler: (_ point: CGPoint, _ index: Int, _ stop: inout Bool) -> Void) {
        var stop = false
        for (i, p) in points.enumerated() {
            handler(p, i, &stop)
            if stop {
                return
            }
        }
    }
    func allBeziers(_ handler: (_ bezier: Bezier3) -> Void) {
        if let fp = points.first, let lp = points.last {
            if points.count == 2 {
                handler(Bezier3.linear(fp, lp))
            } else if points.count >= 3 {
                handler(Bezier3.firstSpline(fp, points[1], points[2]))
                for i in 1 ..< points.count - 2 {
                    handler(Bezier3.spline(points[i - 1], points[i], points[i + 1], points[i + 2]))
                }
                handler(Bezier3.endSpline(points[points.count - 3], points[points.count - 2], lp))
            }
        }
    }
    func allBeziers(_ handler: (_ bezier: Bezier3, _ index: Int, _ stop: inout Bool) -> Void) {
        var stop = false
        if let fp = points.first, let lp = points.last {
            if points.count == 2 {
                handler(Bezier3.linear(fp, lp), 0, &stop)
            } else if points.count >= 3 {
                handler(Bezier3.firstSpline(fp, points[1], points[2]), 0, &stop)
                for i in 1 ..< points.count - 2 {
                    handler(Bezier3.spline(points[i - 1], points[i], points[i + 1], points[i + 2]), i, &stop)
                    if stop {
                        return
                    }
                }
                handler(Bezier3.endSpline(points[points.count - 3], points[points.count - 2], lp), points.count - 2, &stop)
            }
        }
    }
    func addPoints(isMove: Bool, inPath: CGMutablePath) {
        if isMove {
            inPath.move(to: firstPoint)
        }
        allBeziers {
            inPath.addCurve(to: $0.p1, control1: $0.cp0, control2: $0.cp1)
        }
    }
    private struct PressurePoint {
        let point: CGPoint, deltaPoint: CGPoint
        var leftPoint: CGPoint {
            return point + deltaPoint
        }
        var rightPoint: CGPoint {
            return point - deltaPoint
        }
    }
    func draw(size: CGFloat, in ctx: CGContext) {
        ctx.move(to: points.first!)
        allBeziers {
            ctx.addCurve(to: $0.p1, control1: $0.cp0, control2: $0.cp1)
        }
        ctx.setLineWidth(size/2)
        ctx.setStrokeColor(NSColor.black.cgColor)
        ctx.strokePath()
    }
    func drawAutoPressure(size: CGFloat, firstPressure fpr: Float, lastPressure lpr: Float, in ctx: CGContext) {
        let s = size/2
        if points.count >= 2, ctx.boundingBoxOfClipPath.intersects(imageBounds.inset(by: -s)), let fp = points.first, let lp = points.last {
            let fprs = fpr.cf*s, lprs = lpr.cf*s
            let _points = points.count == 2 ? [fp, (fp).mid(lp), lp] : points
            var ps = [PressurePoint]()
            ps.reserveCapacity(points.count)
            var p1 = _points[1], midP0P1 = fp, p0p1 = atan2(p1.y - fp.y, p1.x - fp.x)
            let fTheta = .pi/2 + p0p1, dt = 1/Float(_points.count - 1)
            ps.append(PressurePoint(point: fp, deltaPoint: CGPoint(x: fprs*cos(fTheta), y: fprs*sin(fTheta))))
            for i in 2 ..< _points.count - 1 {
                let p2 = _points[i], hs = autoPressure(dt*Float(i - 1), fp: fpr, lp: lpr).cf*s
                let p1p2 = atan2(p2.y - p1.y, p2.x - p1.x), midP1P2 = p1.mid(p2)
                addPressurePointWith(p0: midP0P1, p1: p1, p2: midP1P2, p0p1: p0p1, p1p2: p1p2, halfSize: hs, inPressurePoints: &ps)
                p1 = p2
                midP0P1 = midP1P2
                p0p1 = p1p2
            }
            let p1p2 = atan2(lp.y - p1.y, lp.x - p1.x), lhs = autoPressure(dt*Float(_points.count - 2), fp: fpr, lp: lpr).cf*s
            addPressurePointWith(p0: midP0P1, p1: p1, p2: lp, p0p1: p0p1, p1p2: p1p2, halfSize: lhs, inPressurePoints: &ps)
            let ltheta = .pi/2 + p1p2
            ps.append(PressurePoint(point: lp, deltaPoint: CGPoint(x: lprs*cos(ltheta), y: lprs*sin(ltheta))))
            addSplinePoints(ps, in: ctx)
            ctx.fillPath()
        }
    }
    private func autoPressure(_ t: Float, fp: Float, lp: Float) -> Float {
        return 4*((t < 0.5 ? fp : lp) - 1)*(t  - 0.5)*(t - 0.5) + 1
    }
    private func addPressurePointWith(p0: CGPoint, p1: CGPoint, p2: CGPoint, p0p1: CGFloat, p1p2: CGFloat, halfSize prs: CGFloat, inPressurePoints ps: inout [PressurePoint]) {
        let p0p2 = atan2(p2.y - p0.y, p2.x - p0.x)
        let theta0 = .pi/2 + (p0p1 + p0p2.loopValue(other: p0p1, begin: -.pi, end: .pi))/2
        ps.append(PressurePoint(point: p0.mid(p1), deltaPoint: CGPoint(x: prs*cos(theta0), y: prs*sin(theta0))))
        let theta1 = .pi/2 + (p0p2 + p1p2.loopValue(other: p0p2, begin: -.pi, end: .pi))/2
        ps.append(PressurePoint(point: p1.mid(p2), deltaPoint: CGPoint(x: prs*cos(theta1), y: prs*sin(theta1))))
    }
    private func addSplinePoints(_ ps: [PressurePoint], in ctx: CGContext) {
        var op = ps[0].leftPoint
        ctx.move(to: op)
        op = ps[1].leftPoint
        if ps.count > 3 {
            for i in 2 ..< ps.count - 1 {
                let p = ps[i].leftPoint
                ctx.addQuadCurve(to: op.mid(p), control: op)
                op = p
            }
            let lp = ps[ps.count - 1]
            ctx.addQuadCurve(to: lp.leftPoint, control: op)
            ctx.addLine(to: lp.rightPoint)
            op = ps[ps.count - 2].rightPoint
            for i in (1...ps.count - 3).reversed() {
                let p = ps[i].rightPoint
                ctx.addQuadCurve(to: op.mid(p), control: op)
                op = p
            }
        } else {
            let lp = ps[ps.count - 1]
            ctx.addQuadCurve(to: lp.leftPoint, control: op)
            ctx.addLine(to: lp.rightPoint)
            op = ps[1].rightPoint
        }
        ctx.addQuadCurve(to: ps[0].rightPoint, control: op)
    }
    private func addLinearLinePoints(fp: CGPoint, lp: CGPoint, fprs: CGFloat, lprs: CGFloat, in ctx: CGContext) {
        let theta = .pi/2 + atan2(lp.y - fp.y, lp.x - fp.x)
        let cf = fprs*cos(theta), sf = fprs*sin(theta), cf2 = lprs*cos(theta), sf2 = lprs*sin(theta)
        ctx.move(to: CGPoint(x: fp.x + cf, y: fp.y + sf))
        ctx.addLine(to: CGPoint(x: lp.x + cf2, y: lp.y + sf2))
        ctx.addLine(to: CGPoint(x: lp.x - cf2, y: lp.y - sf2))
        ctx.addLine(to: CGPoint(x: fp.x - cf, y: fp.y - sf))
    }
}


//cell

func lassoSplitLine(_ line: Line) -> [Line]? {
    var intersects = false
    for lassoLine in lines {
        if line.imageBounds.intersects(lassoLine.imageBounds) {
            intersects = true
            break
        }
    }
    if intersects {
        var newLines = [Line](), firstPointInPath = path.contains(line.firstPoint), lastPointInPath = path.contains(line.lastPoint), oldIndex = 0, oldT = 0.0.cf
        var splitLine = false, leftIndex = 0
        line.allBeziers { b0, i0, stop in
            var results = [BezierIntersection]()
            if var oldLassoLine = lines.last {
                for lassoLine in lines {
                    let lp = oldLassoLine.lastPoint, fp = lassoLine.firstPoint
                    if lp != fp {
                        results += b0.intersections(Bezier2.linear(lp, fp))
                    }
                    lassoLine.allBeziers { b1, i1, stop in
                        results += b0.intersections(b1)
                    }
                    oldLassoLine = lassoLine
                }
            }
            if !results.isEmpty {
                results.sort { $0.t < $1.t }
                for result in results {
                    let newLeftIndex = leftIndex + (result.isLeft ? 1 : -1)
                    if firstPointInPath {
                        if leftIndex != 0 && newLeftIndex == 0 {
                            newLines.append(line.splited(startIndex: oldIndex, startT: oldT, endIndex: i0, endT: result.t))
                        } else if leftIndex == 0 && newLeftIndex != 0 {
                            oldIndex = i0
                            oldT = result.t
                        }
                    } else {
                        if leftIndex != 0 && newLeftIndex == 0 {
                            oldIndex = i0
                            oldT = result.t
                        } else if leftIndex == 0 && newLeftIndex != 0 {
                            newLines.append(line.splited(startIndex: oldIndex, startT: oldT, endIndex: i0, endT: result.t))
                        }
                    }
                    leftIndex = newLeftIndex
                }
                splitLine = true
            }
        }
        if splitLine && !lastPointInPath {
            newLines.append(line.splited(startIndex: oldIndex, startT: oldT, endIndex: line.count - 2, endT: 1))
        }
        if !newLines.isEmpty {
            return newLines
        } else if !splitLine && firstPointInPath && lastPointInPath {
            return []
        }
    }
    return nil
}
